# 列表和数组
列表是有序的标量集合，数组是包含列表的变量。  
也可以说，列表是数据，数组是变量，元素数量不限。  

元素索引值从 0 开始，按 1 递增，类似：$array[1]  
非整数类型的索引值会被去尾规范为整数，如：5.7 -> 5  
超出索引范围的元素值，和未初始化变量一样，默认为 *undef*  

数组最后一个元素的索引值可以用 *$#array* 得到。  
最后一个元素的实际值可以用 *$array[$#array]* 得到。  
类似，也可以用 *$array[-1]* 得到最后一个元素实际值。  

列表可以使用 *()* 符号直接创建，如 *(1,2,3)*  
列表值可混合使用数据类型，如果末尾有 *,* 会被忽略。  
空列表用 *()* 表示，区间操作符 *a..b* 可创建整数列。  
注意区间边界值会被去尾规范为整数，且必须有 *a < b*  
区间边界值接受变量或其他动态值，如 *$a* 或 *$#array*  

如果列表仅包含字符串类型数据，可用 *qw* 操作符简化输入。  
如 ("a","b","c") 和 qw/ a b c / 得到的结果一样。  
*qw* 的边界标识符可以是任意特殊字符，如：!, %, {}, <>  

使用列表可以批量为变量赋值：($a,$b,$c) = ("a","b","c")  
也可以用列表来交换变量或数组值：($a,$b) = ($b,$a)  
赋值时，多余的值会被忽略，不足的值会用 *undef* 填充。  

数组可以用类似方法赋值：($r[0],$r[1],$r[2]) = qw& a b c &  
如果是整个数组可用 *@* 表示，上式等同于：@r = qw% a b c %  
因为列表兼容多种数据类型，所以可以有：@r = (@r, $a, "d")  

*pop* 和 *push* 可以删除或添加数组尾部的元素。  
*pop* 会返回删除的元素，*push* 可以添加一个元素或数组。  
类似的，*shift* 和 *unshift* 可以在数组头部添加或删除元素。  
*shift* 会返回删除的元素，*unshift* 会添加元素或数组。  

需要留意在字符串中引用数组的操作，例如 "@rocks"  
如果同时存在 "@rocks" 和 "$rocks" 用 *{}* 标记变量。  
或者也可用 '' 来单独标记变量，或用 \ 逃逸变量后的 [] 符号。  

遍历数组可以用 *foreach $item (@array)* 方法。  
变量 *$item* 即数组元素，可以在循环体中直接对其修改。  
如果不指定 *$item* ，和其他函数一样，缺省变量可以用 *$_*。  

对数组进行排序或倒序操作使用 *sort* 和 *reverse* 方法。  
注意 *sort* 方法按字符串方式排序，所以 101 排在 99 之后。  
另外 *sort* 方法只返回倒序处理结果，并不修改原来的数组。  
而 *reverse* 方法可以弥补 x..z 自动序列不支持倒序的不足。  

## 上下文
因为十分重要，所以这里独立出来强调一下代码上下文的意义：  
即一个给定的表达式在不同地方会具有不同的意义，例如：  
* 5 + somevar：Perl 会尝试把 somevar 解释为一个标量  
* sort + somevar：Perl 会尝试把 somevar 解释为一个数组

以下上下文情况下默认 *something* 为标量：  
* $fred = something
* $fred[3] = something
* 123 + something
* if (something) {...}
* while (something) {...}
* $fred[something] = something

以下上下文情况下默认 *something* 为列表：  
* @fred = something
* ($fred, $barney) = something
* ($fred) = something
* push @fred, something
* foreach $fred (something) {...}
* sort something
* reverse something
* print something

需要注意的是单元素列表依然为列表，如：@fred = 6 * 7  
清空列表用 *()* 而不是 *undef* 因为后者生成单元素列表。  
如果需要强制使用标量上下文，可用 *scalar* 假函数。  

上下文的另一个特殊用例是标准输入接口 *<STDIN>*  
列表上下文中他会按行读取用户输入，直到按下 Ctrl+D 或 Z  
读入所有行输入，不带换行符：`chomp(@lines=<STDIN>)`  