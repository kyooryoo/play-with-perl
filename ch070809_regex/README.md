# 正则表达式
正则表达式是一种语言规范，用来对字符做匹配。  
执行匹配的结果只有 *匹配* 或 *不匹配* 两种。  

正则表达式用 */* 包裹，简单模式下匹配指定文字。  
元字符有特殊意义，如 *.* *\\* *\** *?* *+* 等  
*(xxx)* 标记分组的内容，要结合上面的元字符使用。  
*|* 表示或，如 *( |\t)* 表示空格或制表符。  
*?* 表示前面相邻的一个或一组内容可有可无。  
*+* 表示匹配前面相邻的一个或一组内容一次或多次。  
*\** 匹配前面相邻的一个或一组内容零次或多次。  

## 另有一些匹配原则和方法如下：  
*\[xyz\]* 中括号匹配其中的任意单个字符  
*-* 可以用来指定数字或字母的匹配区间  
*^* 可以用来反置指定的匹配内容
* HAL-\[0-9\]+ 匹配 *HAL-7250* 等电脑名称
* \[^def\] 匹配除了指定字符 d e f 外的其他字符  

字符类内容支持如下快捷方式  
* \[0-9\] = \\d 即单个数字  
* \[A-Za-z0-9_\] = \\w 即单个字母，数字或下划线  
* \[\\f\\t\\n\\r \] = \\s 即任意类型单个空格或断行  
例如如 \[\\dA-Fa-f\]+ 匹配十六进制的数字。  

以上快捷方式用大写字母，即是其反置形式。  
例如 \\D 即匹配非单个数字的任意其他字符。 

大括号 *{a,b}* 可用来指定匹配的最小和最大次数。  
例如 `/a{5,15}/` 匹配字母 *a* 5 到 15 次。  
也可只指定上限或下限，或一个准确的数目，例如：  
* `/(fred){3,}/` 匹配连续三次及以上的 *fred*  
* `/\w{8}/` 匹配包含 8 个连续字符的字符串  
实际上之前提到的 \*, \+ 和 ? 等同于如下表示：  
* `* = {0,}` 即匹配零次或多次  
* `+ = {1,}` 即匹配一次或多次  
* `? = {0,1}` 即匹配零次或一次  

锚位符 ^ 和 $ 指定匹配发生的位置，即每行的开头或末尾。  
* 如 `/^fred/` 仅匹配每行头部的 fred  
* 而 `/rock$/` 仅匹配每行尾部的 rock  
* `/^\s*$/` 匹配一个空行  
单词锚位符 \\b 用来标记独立单词的头部或尾部。  
* 如 `/\bfred\b/` 仅匹配单个独立的 fred 单词
注意这里的单词指由 \w 构成的字符串，包括 *_* 和数字。  
* 如 That's 是两个独立的单词，而 9_a 是一个单词  
* `/\bhunt/` 匹配 hunt, hunting, 或 hunter 等  
另有 \\B 表示非单词边界，可用来专门匹配各种单词变体：  
* 如 `/\bsearch\B/` 匹配 searches 或 searching 等  
* 但是不会和 search, research 或 researching 等匹配  

## 反向引用和记忆变量
用于标记组的 *\(\)* 符号也做反向引用和创建记忆变量之用。  
在匹配模式定义中，可以用 \\n 做反向引用，*n* 为数字。  
* 例如 `/(.)\1/` 匹配任意连续出现的单个字符（同一字符）  
* 注意以上模式与 `/../` 不同在于后者匹配任意两个连续字符  

一个应用场景是匹配 HTML 文件中的图片元素定义如：  
* `<image source='fred.png'>`  
* `<image source="fred's-birthday.png">`  
注意，第一个图片元素使用单引号标记图片路径。  
第二个图片元素路径中有单引号，所以用双引号标记了路径。  
如果要相对精确的匹配到如上两个图片元素，可用如下模式：  
`/<image source=(['"]).*\1>/`  
* `['"]` 匹配单引号或双引号中的任意一个  
* `()` 将其中的内容做为一组并以备引用   
* `.*` 匹配零个或任意多个连续的字符  
* `\1` 引用之前匹配到的第一个组，也就是单引号或双引号  

如果模式中有多组小括号，按照左括号的个数依次匹配引用。  
例如 `/((fred|wilma) (flintstone)/` 有反向引用：  
* `\1` 引用 *fred flintstone* 或 *wilma flintstone*  
* `\2` 引用 *fred* 或 *wilma*  
* `\3` 引用 *flintstone*  
需要留意的是，一旦匹配成功，引用内容必须和匹配项一致。  
* `/((a|b) (c)) \1/` 匹配 *acac* 或 *bcbc* 但不匹配 *acbc* 或 *bcac*  
* `/((a|b) (c)) \2/` 匹配 *aca* 或 *bcb* 但不匹配 *acb* 或 *bca*  
* `/((a|b) (c)) \3/` 只匹配 *acc* 或 *bcc* 当然这样的静态引用很少见  

通过小括号匹配的内容在匹配结束后仍可以通过记忆变量引用。  

## 操作符优先级
这部分内容也很重要，所里独立一个标题强调一下。  
正则表达式中的各种操作符遵循如下的四级优先级顺序：  
* 最高优先级是小括号，用于创建分组和记忆变量。  
* 第二级是数量操作符，即 \*, \+, ? 和 \{\}。
* 第三级是锚位符（^, $, \\b, \\B）和文本序列。  
* 最后是选择操作符 | 例如 `/fred|barney/`。  

举个栗子：`/^fred|barney$/` 和 `/^(fred|barney)$/`  
* 前者匹配所有以 *fred* 开始或以 *barney* 结束的行  
* 后者匹配所有只包含 *fred* 和 *barney* 的行  
因为选择操作符的优先级最低，使用时需要留意如上场景。  

再如 `/(wilma|pebbles?)/` 匹配如下内容：  
*wilam*, *pebbles*, 或 *pebble*  
再如 `/^(\w+)\s+(\w+)$/` 匹配两个单词和之间的空格。  

再来几个栗子：  
* `/"([^"]*)"/` 匹配双引号内的非双引号字符串  
* `/^0?[0-3]?[0-7]{1,2}$/` 包含首尾的全字段匹配  
+ 首位 0 可有可无  
+ 次位 0 到 3 可有可无  
+ 后接一到二位数字，取值 0 到 7  
* `/^\b[\w.]{1,12}\b$/` 包含首尾的全字段匹配  
+ 首尾包含单词边界  
+ 中间内容为 1 到 12 位的单词字符或任意字符  

## 高级主题
这个关于正则表达式的章节已经很长，但为了方便还是继续了。  

### 定制化模式定界符
模式定义默认使用 / 符号包裹，但其实可以自定义其他符号。  
类似 qw 操作符，可以用任意成对或不成对符号包裹模式定义。  
例如，对假设 fred 的模式定义，以下的方法都是合法的：  
* `/fred/` - 这是默认的定义方式，可以省略 `m`  
* `m(fred)` `m<fred>` `m{fred}` - 使用成对的标识符  
* `m!fred!` `m^fred^` `m,fred,` - 使用不成对的标识符  
使用模式中不包含的符号做定界符可以增加代码可读性。  
使用大括号做定界符在代码编辑器中可能获得额外提示优势。

### 选项修饰符
附加在正则表达式结束定界符后，改变表达式的缺省行为模式。  
* /i - 不区分大小写匹配  
* /s - 为 `.` 增加对换行符的匹配  
如需使用多个选项修饰符，可以连续组合使用，顺序不重要。  

### 绑定操作符
`$_` 是默认的匹配目标，绑定操作符 `=~` 可指定其他目标。  
匹配操作返回表示是否匹配成功的布尔值结果，所以如下可行：  
`if (/regex/) {...}` 的原型为 `if ($_ =~ /regex/) {...}`  

### 在模式中替换
模式定义中可以用变量，即 `/^($what)/` 的方法定义模式。  
变量可以从外部参数列表 *@ARGV* 中读取，注意逃逸特殊字符。  
例如如果从外部参数读取模式定义 `a|b` 需要输入 `a\|b`  

### 匹配变量
匹配变量对应的是反向引用，分别用 `$n` 和 `\n` 表示。  
两个的值相同，匹配变量在模式外使用，反向引用在模式内使用。  
匹配变量在下次成功匹配之前有效，随下次成功匹配全部清空。  
在不同批次的匹配间保留匹配变量值，可以转存到其他命名变量。  

Perl 还支持若干内置匹配变量，名字为：*$&* *$`* 和 *$'*  
他们分别存有匹配部分的内容，之前， 和之后的内容。  
使用这些默认匹配变量会牺牲性能，可用小括号配合 *$n* 替代。  

### 本地替换
regex 的另一个应用是用 `$v =~ s/x/y/` 对 `$v` 做本地替换。  
其中 x 是用作匹配的 regex 而 y 是指定对匹配做替换的内容。  
例如 `s/Barney/Fred/` 匹配并替换 Barney 为 Fred  
用记忆变量 `s/with (\w+)/against $1/` 替换 with 为 against  
更多替换用例可以参考 `16_replace.pl` 文件中的代码。  

配合记忆变量，可以使用 `\U`, `\u`, `\L`, `\l` 做大小写转换。  
* `\U` 和 `\L` 分别强制之后的所有字符为大写或小写  
* `u` 和 `l` 分别强制之后的一个字符为大写或小写  
为防止意外，一个好的习惯是在目标大小写转换字符后用 `\E` 关闭。  
否则 `U` 和 `L` 的大小写替换操作会从开始位置一直作用到行末。  
另外，`s///`只是一种场景，大小写替换可以直接在字符串中作用。  

添加 `/g` 尾缀可匹配所有可匹配对象，添加 `/i` 不区分大小写。  
在使用 `.*` 时，如添加 `/s` 尾缀可额外匹配到 `\n` 断行符。  

### 分割操作
使用 `@result = split /separator/, $string` 可以分割字符串。  
分割标记为 `separator` 操作对象为 `$string` 返回为 `@result`  
例如 `split /:/, "a:b:c"` 返回 `("a","b","c")`
上例中如果有 `::` 则前置和中置者返回 `""` 而后置者会被抛弃。  
分隔标记可以用正则表达式，但模式定义中需要避免使用记忆符号。  

分割的逆向操作是粘合 `my $result = join $glue, @pieces`  
注意第一个参数 `$glue` 是用于粘合元素的字符串，而不是模式。  
